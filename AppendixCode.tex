\appendixpagenumbering
\chapter{Code} 


\section{Vehicle Visualization URDF Model}
\begin{verbatim}

<robot name="rsl_roverzoe">
<link name="base_link">
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0" />
      <geometry>
          <mesh filename="package://rsl_rover/urdf/RoughBody_corrected.stl"/>
      </geometry>

    
    </visual>
 
    <collision><!-- Test values for now -->
         <geometry>
           <box size="300 200 200" />
         </geometry>
    </collision>
  
</link>

<!-- Front Right Wheel -->
<joint name="body_to_fr_tire" type="fixed" >
	<parent link="base_link" />
	<child link="fr_tire" />
	<origin xyz="1.9431 -0.584 0" rpy="0 0 0" />
	<axis xyz="0 1 0" />
</joint>
<link name="fr_tire">
   <visual>
	<geometry>
	<mesh filename="package://rsl_rover/urdf/Tire_corrected.stl"/>
	</geometry>
     </visual>
</link>

<!-- Front Left Wheel -->
<joint name="body_to_fl_tire" type="fixed" >
	<parent link="base_link" />
	<child link="fl_tire" />
	<origin xyz="1.9431 0.584 0" rpy="0 0 0" />
	<axis xyz="0 1 0" />
</joint>
<link name="fl_tire">
   <visual>
	<geometry>
	<mesh filename="package://rsl_rover/urdf/Tire_corrected.stl"/>
	</geometry>
     </visual>
</link>

<!-- Center Right Wheel -->
<joint name="body_to_cr_tire" type="fixed" >
	<parent link="base_link" />
	<child link="cr_tire" />
	<origin xyz="0.3429 -0.584 0" rpy="0 0 0" />
	<axis xyz="0 1 0" />
</joint>
<link name="cr_tire">
   <visual>
	<geometry>
	<mesh filename="package://rsl_rover/urdf/Tire_corrected.stl"/>
	</geometry>
     </visual>
</link>

<!-- Center Left Wheel -->
<joint name="body_to_cl_tire" type="fixed" >
	<parent link="base_link" />
	<child link="cl_tire" />
	<origin xyz="0.3429 0.584 0" rpy="0 0 0" />
	<axis xyz="0 1 0" />
</joint>
<link name="cl_tire">
   <visual>
	<geometry>
	<mesh filename="package://rsl_rover/urdf/Tire_corrected.stl"/>
	</geometry>
     </visual>

<!-- Back Right Wheel -->
</link><joint name="body_to_br_tire" type="fixed" >
	<parent link="base_link" />
	<child link="br_tire" />
	<origin xyz="-0.3429 -0.584 0" rpy="0 0 0" />
	<axis xyz="0 1 0" />
</joint>
<link name="br_tire">
   <visual>
	<geometry>
	<mesh filename="package://rsl_rover/urdf/Tire_corrected.stl"/>
	</geometry>
     </visual>
</link>

<!-- Back Left Wheel -->
<joint name="body_to_bl_tire" type="fixed" >
	<parent link="base_link" />
	<child link="bl_tire" />
	<origin xyz="-0.3429 0.584 0" rpy="0 0 0" />
	<axis xyz="0 1 0" />
</joint>
<link name="bl_tire">
   <visual>
	<geometry>
	<mesh filename="package://rsl_rover/urdf/Tire_corrected.stl"/>
	</geometry>
     </visual>
</link>



<!-- Front_Laser -->
<joint name="body_to_front_laser" type="fixed" >
	<parent link="base_link" />
	<child link="front_laser" />
	<origin xyz="2.4 0 0.24" rpy="3.1416 0 0" />
	<axis xyz="0 1 0" />
</joint>
<link name="front_laser">
   <visual>
	<geometry>
	<box size=".5 .5 .01" />
	</geometry>
     </visual>
</link>


<!-- Gimbal_Base -->
<joint name="body_to_gimbal_base" type="fixed" >
	<parent link="base_link" />
	<child link="gimbal_base" />
	<!--<origin xyz=".978 0 1.892" rpy="0 0 0" />-->
	<origin xyz="1.1 0 1.892" rpy="0 0 0" />
	<axis xyz="0 1 0" />
</joint>
<link name="gimbal_base">
   <visual>
	<geometry>
	<box size=".5 .5 .01" />
	</geometry>
     </visual>
</link>

<!-- Imu Link -->
<joint name="body_to_imu_link" type="fixed" >
	<parent link="base_link" />
	<child link="imu_link" />
	<origin xyz="0 0 0.5" rpy="0 0 0" />
	<axis xyz="0 1 0" />
</joint>
<link name="imu_link">
   <visual>
	<geometry>
	<box size=".05 .05 .05" />
	</geometry>
     </visual>
</link>

<!-- Base Footprint Link (base link shifted down to under the wheels) -->
<joint name="body_to_base_footprint" type="fixed" >
	<parent link="base_link" />
	<child link="base_footprint" />
	<origin xyz="0 0 -0.3429" rpy="0 0 0" />
	<axis xyz="0 0 0" />
</joint>
	<link name="base_footprint">
</link>

<joint name="body_to_front_camera" type="fixed" >
	<parent link="base_link" />
	<child link="front_camera" />
	<origin xyz="1.0 0 1.0" rpy="3.14 0 0" />
	<axis xyz="0 0 0" />
</joint>
	<link name="front_camera">
</link>
</robot>
\end{verbatim}

\section{Cameras Launch File}
\begin{verbatim}
<launch>
	<arg name="fps" default="10" />	
	<arg name="width" default="432" />	
	<arg name="height" default="240" />	

	<node name="camera_web_server" pkg="web_video_server"  type="web_video_server" output="screen">
		<param name="port" value="8080" />
		<param name="address" value="10.0.0.111" />
		<param name="server_threads" value="1" />
		<param name="ros_threads" value="2" />
		<param name="quality" value="90" />
	</node>

	<node pkg="uvc_camera" type="uvc_camera_node" name="camerafront" output="screen">
		<remap from="/image_raw" to="/camerafront_raw" />
		<param name="device" value="/dev/camerafront" />
		<param name="camera_info_url" value="file:///home/ubuntu/cfg/cameracalib/camerafront.yaml" />
		<param name="fps" value="$(arg fps)" />
		<param name="width" value="$(arg width)" />
		<param name="height" value="$(arg height)" />
		<param name="frame" value="front_camera" />
	</node>

	<node pkg="uvc_camera" type="uvc_camera_node" name="cameraright">
		<remap from="/image_raw" to="/cameraright_raw" />
		<param name="device" value="/dev/cameraright" />
		<param name="camera_info_url" value="file:///home/ubuntu/cfg/cameracalib/cameraright.yaml" />
		<param name="fps" value="$(arg fps)" />
		<param name="width" value="$(arg width)" />
		<param name="height" value="$(arg height)" />
	</node>

	<node pkg="uvc_camera" type="uvc_camera_node" name="cameraleft">
		<remap from="/image_raw" to="/cameraleft_raw" />
		<param name="device" value="/dev/cameraleft" />
		<param name="camera_info_url" value="file:///home/ubuntu/cfg/cameracalib/cameraleft.yaml" />
		<param name="fps" value="$(arg fps)" />
		<param name="width" value="$(arg width)" />
		<param name="height" value="$(arg height)" />
	</node>

	<node pkg="uvc_camera" type="uvc_camera_node" name="camerarear">
		<remap from="/image_raw" to="/camerarear_raw" />
		<param name="device" value="/dev/camerarear" />
		<param name="camera_info_url" value="file:///home/ubuntu/cfg/cameracalib/camerarear.yaml" />
		<param name="fps" value="$(arg fps)" />
		<param name="width" value="$(arg width)" />
		<param name="height" value="$(arg height)" />
	</node>

<!--	<node name="people_detect" pkg="opencv_apps" type="people_detect" args="image:=/cameraright_raw"/>  -->

</launch>
\end{verbatim}

\section{Camera Calibration: Front}
\begin{verbatim}
image_width: 640
image_height: 480
camera_name: camera
camera_matrix:
  rows: 3
  cols: 3
  data: [652.560454, 0.000000, 319.752367, 0.000000, 650.694801, 248.296020, 0.000000, 0.000000, 1.000000]
distortion_model: plumb_bob
distortion_coefficients:
  rows: 1
  cols: 5
  data: [-0.040380, -0.112498, -0.005992, 0.003583, 0.000000]
rectification_matrix:
  rows: 3
  cols: 3
  data: [1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000]
projection_matrix:
  rows: 3
  cols: 4
  data: [640.549927, 0.000000, 321.096783, 0.000000, 0.000000, 644.552368, 246.303601, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000]
\end{verbatim}


\section{Camera Calibration: Left}
\begin{verbatim}
image_width: 640
image_height: 480
camera_name: camera
camera_matrix:
  rows: 3
  cols: 3
  data: [680.338468, 0.000000, 308.172392, 0.000000, 680.430062, 268.088277, 0.000000, 0.000000, 1.000000]
distortion_model: plumb_bob
distortion_coefficients:
  rows: 1
  cols: 5
  data: [-0.071290, 0.126918, 0.012577, -0.003966, 0.000000]
rectification_matrix:
  rows: 3
  cols: 3
  data: [1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000]
projection_matrix:
  rows: 3
  cols: 4
  data: [677.564697, 0.000000, 305.707383, 0.000000, 0.000000, 674.015991, 271.888351, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000]
\end{verbatim}


\section{Camera Calibration: Rear}
\begin{verbatim}
image_width: 640
image_height: 480
camera_name: camera
camera_matrix:
  rows: 3
  cols: 3
  data: [652.885564, 0.000000, 294.983103, 0.000000, 655.716920, 239.362656, 0.000000, 0.000000, 1.000000]
distortion_model: plumb_bob
distortion_coefficients:
  rows: 1
  cols: 5
  data: [-0.070639, 0.052269, 0.001334, -0.000681, 0.000000]
rectification_matrix:
  rows: 3
  cols: 3
  data: [1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000]
projection_matrix:
  rows: 3
  cols: 4
  data: [642.366028, 0.000000, 293.619005, 0.000000, 0.000000, 648.596558, 239.218096, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000]
\end{verbatim}


\section{Camera Calibration: Right}
\begin{verbatim}
image_width: 640
image_height: 480
camera_name: camera
camera_matrix:
  rows: 3
  cols: 3
  data: [652.817375, 0.000000, 311.656932, 0.000000, 654.014227, 249.445159, 0.000000, 0.000000, 1.000000]
distortion_model: plumb_bob
distortion_coefficients:
  rows: 1
  cols: 5
  data: [-0.076846, 0.091739, -0.001813, -0.003684, 0.000000]
rectification_matrix:
  rows: 3
  cols: 3
  data: [1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000]
projection_matrix:
  rows: 3
  cols: 4
  data: [642.887573, 0.000000, 309.222547, 0.000000, 0.000000, 647.120850, 248.549064, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000]
\end{verbatim}


\section{LIDAR Scan to Point Cloud}
\begin{verbatim}
#include "ros/ros.h"
#include "ros/message.h"

#include "tf/transform_listener.h"
#include "sensor_msgs/PointCloud2.h"
#include "sensor_msgs/PointField.h"
#include "tf/message_filter.h"
#include "message_filters/subscriber.h"
#include "laser_geometry/laser_geometry.h"
#include "ros/console.h"

#include <vector>
#include <string>
class LaserScanToPointCloud{

public:

  ros::NodeHandle n_;
  laser_geometry::LaserProjection projector_;
  tf::TransformListener listener_;
  message_filters::Subscriber<sensor_msgs::LaserScan> laser_sub_;
  tf::MessageFilter<sensor_msgs::LaserScan> laser_notifier_;
  ros::Publisher scan_pub_;

  LaserScanToPointCloud(ros::NodeHandle n) : 
    n_(n),
    laser_sub_(n_, "scanlms221", 10),
    laser_notifier_(laser_sub_,listener_, "base_link", 10)
  {
    laser_notifier_.registerCallback(
      boost::bind(&LaserScanToPointCloud::scanCallback, this, _1));
    laser_notifier_.setTolerance(ros::Duration(0.01));
    scan_pub_ = n_.advertise<sensor_msgs::PointCloud2>("/ass_cloud",1);
  }

  void scanCallback (const sensor_msgs::LaserScan::ConstPtr& scan_in)
  {
    sensor_msgs::PointCloud2 cloud;
    try
    {
        projector_.transformLaserScanToPointCloud(
          "base_link",*scan_in, cloud,listener_);
    }
    catch (tf::TransformException& e)
    {
        std::cout << e.what();
        return;
    }
    // our scan doesn't come with intensities
    // use the y value as the color value of the point
    int fields_length = cloud.fields.size();
    int y_offset = 0;
    int count = 0;
    for (int i =0; i < fields_length; i++) {
    	if (cloud.fields[i].name == "y") {
		y_offset = cloud.fields[i].offset;
		count = cloud.fields[i].count;
		break;
	}
    }
    sensor_msgs::PointField p;
    p.name = "rgb";
    p.offset= y_offset;
    p.datatype= 6;
    p.count = count;
    cloud.fields.push_back(p);
    
    // Do something with cloud.
    scan_pub_.publish(cloud);

  }
};

int main(int argc, char** argv)
{
  
  ros::init(argc, argv, "my_scan_to_cloud");
  ros::NodeHandle n;
  LaserScanToPointCloud lstopc(n);
  
  ros::spin();
  
  return 0;
}

\end{verbatim}


\section{Vehicle State Information}
\begin{verbatim}
#!/usr/bin/env python
import rospy
import numpy
import binascii
import roslib
import time
import struct
from serial import Serial
from array import array
from collections import namedtuple
from nav_msgs.msg import Odometry
from rsl_rover_msgs.msg import vehicle_state
from math import pi,tan

class RoverInterface: 
   #_rx_len = 0
   # _rx_size = 26
    fmt = 'iffhcchh??????????hf'
    RoverDataKeys = [
        'time',
        'wheel_pos',
        'wheel_speed',
        'desired_throttle',
        'desired_gear',
        'actual_gear',
        'desired_steering',
        'actual_steering',
        'temp_warn',
        'voltage_warn',
        'estop',
        'A', 'B', 'C', 'D', 'E', 'Horn','F',
        'estop_code']

    def __init__(self,ser_in):
        self._rx_size = struct.calcsize(self.fmt)
        self.ser = ser_in
        self._rx_len = 0
        self.rx_buffer = bytearray(self._rx_size+1)
        self.rx_array_inx = 0
        self.RoverState = dict()

    def receiveData(self):
        ser = self.ser
        #global rx_len, rx_buffer,rx_array_inx, RoverDataKeys, RoverData
        #Translated from the c++ arduino Easy Transfer Library
        if self._rx_len == 0:
            if ser.inWaiting() >= 3:
                while ser.read() != '\x06':
                    if ser.inWaiting() < 3:
                        return False

                if ser.read() == '\x85':
                    self._rx_len = ord(ser.read())
                    if self._rx_len != self._rx_size:
                        self._rx_len = 0
                        return False
        
        if self._rx_len != 0:
            while ser.inWaiting() and self.rx_array_inx <= self._rx_len:
                try:
                    self.rx_buffer[self.rx_array_inx] = ser.read()
                    self.rx_array_inx += 1
                except Exception, err:
                    rospy.logwarn('Error while reading after start bits',err)

        if(self._rx_len == (self.rx_array_inx-1)):
            calc_CS = self._rx_len
            for i in range(0,self._rx_len):
                calc_CS ^= self.rx_buffer[i]

            if calc_CS == self.rx_buffer[self.rx_array_inx-1]:
                try:
                    self.decodeStruct(self.rx_buffer[0:-1])
                except Exception, err:
                    rospy.logwarn(err)
                    rospy.logwarn('Failed to Decode Packet')
                    rospy.logwarn(binascii.b2a_hex(self.rx_buffer[0:-1]))
                self._rx_len = 0
                self.rx_array_inx = 0
                return True
            else:
                self._rx_len = 0
                self.rx_array_inx = 0
                return False

    def decodeStruct(self,data):
        #print ''.join('{:02x}'.format(x) for x in self.rx_buffer[0:-1])
        values = struct.unpack(self.fmt,data)
        self.RoverState = dict(zip(self.RoverDataKeys,values))

    def getRoverState(self):
        return self.RoverState

if __name__ == '__main__':
    ser = Serial(
           port='/dev/rover',
           baudrate=115200,
           timeout=0.1,
           dsrdtr=False,
            )
    rover = RoverInterface(ser)
    pub = rospy.Publisher('VehicleTach',Odometry,queue_size=2)
    pub_state = rospy.Publisher('VehicleState',vehicle_state,queue_size=2)
    rospy.init_node('RoverInterface')
    rate = rospy.Rate(100)

    while not rospy.is_shutdown():
        rover.receiveData()
        RS = rover.getRoverState()
        try:
            #Build up odometry message
            odom_msg = Odometry()
            odom_msg.header.stamp = rospy.Time.now()
            odom_msg.header.frame_id = "odom"
            odom_msg.child_frame_id = "base_link"
            
            wheel_speed_rpm = RS['wheel_speed']
            wheel_pos_r = RS['wheel_pos']
            steering = RS['actual_steering']
                #Wheel diamater is 25" or 0.635m
                #Min to sec divide by 30
                #Multiply by pi to get circumference
            wheel_speed = 0.635 * pi / 60 * wheel_speed_rpm #Convert from rpm to m/s
            wheel_pos = 0.635 * pi * wheel_pos_r
            odom_msg.twist.twist.linear.x = wheel_speed
            odom_msg.twist.twist.linear.y = 0
            #odom_msg.twist.twist.angular.z = wheel_speed*-tan(pi/6*steering/1000.0)/1.97
            odom_msg.twist.covariance = numpy.diag([1e-2,1e-2,1e-2,1e-2,1e-2,1e-2]).flatten().tolist()

            pub.publish(odom_msg)
        except Exception, err:
            rospy.logwarn('Could Not Publish tach_odom');
            rospy.logwarn(err)

        try:
            #Build up vehicle state message
            vs_msg = vehicle_state()
            vs_msg.header.stamp = rospy.Time.now()
            vs_msg.wheel_pos = wheel_pos # Convert from Revs to M
            vs_msg.wheel_speed = wheel_speed #Convert from RPM to M/S
            vs_msg.desired_throttle = RS['desired_throttle']
            vs_msg.desired_gear = RS['desired_gear']
            vs_msg.actual_gear = RS['actual_gear']
            vs_msg.desired_steering = RS['desired_steering']
            vs_msg.actual_steering = RS['actual_steering']
            vs_msg.temp_warn = RS['temp_warn']
            vs_msg.voltage_warn = RS['voltage_warn']
            vs_msg.estop = RS['estop']
            vs_msg.aux = [RS[x] for x in ['A','B','C','D','E','Horn','F']]
            vs_msg.estop_code = RS['estop_code']
            #vs_msg.engine_rpm = RS['engine_rpm']
            pub_state.publish(vs_msg)

        except Exception, err:
            rospy.logwarn('Could Not Publish rover_state');
            rospy.logwarn(err)

        rate.sleep()
\end{verbatim}


\section{GPS Configuration}
\begin{verbatim}
#!/usr/bin/python
import serial
import time
import struct

ser = serial.Serial(
        #port='/dev/ttyUSB0',
        #port='/home/rover-dev/dev/ttyLMS',
        port='/dev/novatel',
        baudrate=115200)

print(ser.isOpen())

#ser.write('\x02\x00\x01\x00\x31\x15\x12')
#cmd = ['COM COM1,115200,N,8,1,N,OFF,ON']
cmd = ['UNLOGALL\r\n', \
#'LOG com1 versiona once\r\n', \
'SBASCONTROL ENABLE ANY 0 NONE\r\n', \
#'SBASCONTROL DISABLE\r\n', \
'LOG com1 GPGGA ontime 0.1\r\n', \
'LOG com1 GPVTG ontime 1\r\n', \
'LOG com1 GPGSV ontime 1\r\n', \
'LOG com1 GPGSA ontime 1\r\n', \
'LOG com1 GPGST ontime 1\r\n', \
'SAVECONFIG\r\n']

for c in cmd:
    print c
    ser.write(c)
    ser.flush()
    time.sleep(0.5)
    output = ''
    while ser.inWaiting() > 0:
        output +=  ser.read() 
    print output

while 1:
    output = []
    if ser.inWaiting() > 0:
        print ser.readline()
#        print output.encode('hex')

ser.close()
\end{verbatim}


\section{GPS Driver Launch}
\begin{verbatim}
<launch>
  <node pkg="nmea_navsat_driver" type="nmea_serial_driver" name="gps_driver">
    <param name="port" value="/dev/novatel" />
    <param name="baud" value="115200" />
  </node>
</launch>
\end{verbatim}

\section{Gimbal Driver}
\begin{verbatim}
#!/usr/bin/env python
import sys
import socket
import rospy
import roslib
import time
import tf
import re
from math import pi
from rsl_rover_msgs.msg import vehicle_state

TCP_IP = '10.0.0.141'
TCP_PORT = 2000
BUFFER_SIZE = 1024
moving = 0
MOVEPAUSE = 0.01
COMMPAUSE = 0.01
COUNTSTORAD = 45837
OFFSET_RAD = pi/2
GOALMAXRAD_FWD = pi/5
GOALMINRAD_FWD = -pi/5
GOALRAD_FWD_STATIC = -pi/8
CALIBRATION_COUNTS = 1150

GOALMAXRAD_REV = pi/5-pi;
GOALMINRAD_REV = -pi/5-pi;
GOALRAD_REV_STATIC = -pi+pi/8

goal = 0#GOALMAXRAD_FWD

lastCMD_T = 0
reversing = False
sweeping = False

def movetorad(s,setpoint):
    goal = (setpoint+OFFSET_RAD)*COUNTSTORAD        
    sendCommandWOResp(s,'GOAL='+str(goal+CALIBRATION_COUNTS))

def moveto(s,pos):
    sendCommandWOResp(s,'GOAL='+str(pos+CALIBRATION_COUNTS))
    moving = 1

def sendPitchTF(br,pitch_rad):
    #br.sendTransform((0,0,0),
    #        tf.transformations.quaternion_from_euler(0,-(pitch_rad-OFFSET_RAD),0),
    #        rospy.Time.now(),
    #        'gimbal_laser',
    #        'gimbal_base')

    br.sendTransform((0,0,0),
            tf.transformations.quaternion_from_euler(0,-pitch_rad,0),
            rospy.Time.now(),
            'gimbal_laser',
            'gimbal_base')

def getpos(s):
    data = sendCommandWResp(s,'TP')
    data = float(bufferToInt(data))/float(COUNTSTORAD) - OFFSET_RAD
    return data
    
def getvel(s):
    data = sendCommandWResp(s,'TV')
    data = float(bufferToInt(data))/float(COUNTSTORAD)
    return data

def sendCommandWOResp(s,cmd):
    s.send(cmd+'\r')
    time.sleep(COMMPAUSE)
    data = s.recv(BUFFER_SIZE) #clear the buffer

def sendCommandWResp(s,cmd):
    s.send(cmd + '\r')
    time.sleep(COMMPAUSE)
    data = s.recv(BUFFER_SIZE)
    return data

def bufferToInt(data):
    data = re.findall(r'-?\d+',data.rstrip())
    data = int(data[0].rstrip())
    return data 

def init():
    rospy.init_node('gimbal_driver')
    br = tf.TransformBroadcaster()
    try:
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect((TCP_IP,TCP_PORT))
    except socket.error as msg:
        rospy.logwarn('PROBLEM CONNECTING',msg)
        sys.exit(1)
    time.sleep(0.1)
    sendCommandWOResp(s,'')
    rospy.loginfo('INIT COMPLETED')
    return (s,br)

def vehicle_state_callback(data):
    global reversing, sweeping
    reversing = data.desired_gear == 'R' 
    sweeping = data.aux[1]
    pass

if __name__ == '__main__':
    try:
        ret = init()
        s = ret[0]
        br = ret[1]
#        sendCommandWOResp(s,'GOAL=10000')
        rate = rospy.Rate(100)

        rover_sub = rospy.Subscriber('VehicleState',vehicle_state, vehicle_state_callback)

        while not rospy.is_shutdown():
            vel = getvel(s)
            pos = getpos(s)
            sendPitchTF(br,pos)
            if vel < 1000.0/COUNTSTORAD:
                moving = False
            else:
                moving = True

            if reversing:
                GOALMINRAD = GOALMINRAD_REV
                GOALMAXRAD = GOALMAXRAD_REV
                GOALRAD = GOALRAD_REV_STATIC
            else:
                GOALMINRAD = GOALMINRAD_FWD
                GOALMAXRAD = GOALMAXRAD_FWD
                GOALRAD = GOALRAD_FWD_STATIC

            if sweeping:
                if not moving and (time.time() - lastCMD_T > 0.2):
                    lastCMD_T = time.time()
                    if pos > (GOALMINRAD+GOALMAXRAD)/2: #GOALMAXRAD:
                        goal = GOALMINRAD
                        movetorad(s,goal)
                    elif pos <=(GOALMINRAD+GOALMAXRAD)/2:#  GOALMINRAD:
                        goal = GOALMAXRAD
                        movetorad(s,goal)
            else:
                movetorad(s,GOALRAD)

            rate.sleep()
    except rospy.ROSInterruptException:
        rospy.logwarn('ROSInterruptException Thrown')
        pass

    sendCommandWOResp(s,'GOAL=0')
\end{verbatim}


\section{Environmental Sensor State Information}
\begin{verbatim}
#!/usr/bin/env python
import re
import traceback
import sys
import rospy
import numpy
import binascii
import roslib
import time
import struct
from serial import Serial
from array import array
from collections import namedtuple
from rsl_rover_msgs.msg import env_data
from math import pi,tan
from MQSensor import MQ
import os
class RoverInterface: 
   #_rx_len = 0
   # _rx_size = 26
    fmt = 'iffffffffffff'
    RoverDataKeys = ['time','Temp1','Temp2','Humidity','Particulate']
    MQNames = ['MQ-4','MQ-135','MQ-9','MQ-2','MQ-5','MQ-6','MQ-7','MQ-8']
    RoverDataKeys = RoverDataKeys + MQNames

    def __init__(self,ser_in):
        self._rx_size = struct.calcsize(self.fmt)
        self.ser = ser_in
        self._rx_len = 0
        self.rx_buffer = bytearray(self._rx_size+1)
        self.rx_array_inx = 0
        self.RoverState = dict()

    def setupMQ(self):
        dbpath = os.path.join(os.path.dirname(MQ.__file__),'mqdb.sqlite')
        self.MQSEN = dict()
        for name in self.MQNames:
            self.MQSEN[name] = MQ.MQ(dbpath,name)

    def receiveData(self):
        ser = self.ser
        #global rx_len, rx_buffer,rx_array_inx, RoverDataKeys, RoverData
        #Translated from the c++ arduino Easy Transfer Library
        if self._rx_len == 0:
            if ser.inWaiting() >= 3:
                while ser.read() != '\x06':
                    if ser.inWaiting() < 3:
                        return False

                if ser.read() == '\x85':
                    self._rx_len = ord(ser.read())
                    if self._rx_len != self._rx_size:
                        self._rx_len = 0
                        return False
        
        if self._rx_len != 0:
            while ser.inWaiting() and self.rx_array_inx <= self._rx_len:
                try:
                    self.rx_buffer[self.rx_array_inx] = ser.read()
                    self.rx_array_inx += 1
                except Exception, err:
                    rospy.logwarn('Error while reading after start bits',err)

        if(self._rx_len == (self.rx_array_inx-1)):
            calc_CS = self._rx_len
            for i in range(0,self._rx_len):
                calc_CS ^= self.rx_buffer[i]

            if calc_CS == self.rx_buffer[self.rx_array_inx-1]:
                try:
                    self.decodeStruct(self.rx_buffer[0:-1])
                except Exception, err:
                    rospy.logwarn(err)
                    rospy.logwarn('Failed to Decode Packet')
                    rospy.logwarn(binascii.b2a_hex(self.rx_buffer[0:-1]))
                self._rx_len = 0
                self.rx_array_inx = 0
                return True
            else:
                self._rx_len = 0
                self.rx_array_inx = 0
                return False

    def decodeStruct(self,data):
        #print ''.join('{:02x}'.format(x) for x in self.rx_buffer[0:-1])
        values = struct.unpack(self.fmt,data)
        self.RoverState = dict(zip(self.RoverDataKeys,values))

    def getRoverState(self):
        return self.RoverState

if __name__ == '__main__':

    rospy.init_node('EnviroDataNode')
    serport = rospy.get_param('~port')
    rospy.loginfo(serport)

    ser = Serial(
           port=serport,
           baudrate=115200,
           timeout=0.1,
            )

    rover = RoverInterface(ser)
    rover.setupMQ()
    pub = rospy.Publisher('EnvData',env_data,queue_size=2)
    rate = rospy.Rate(5)
    setupsamples = 0
    setup_sample_list = []

    while not rospy.is_shutdown():
        rover.receiveData()
        ES = rover.getRoverState()
        
        if setupsamples < 20:
            if len(ES) > 0:
                setup_sample_list.append(ES)
                setupsamples += 1

            if(setupsamples == 19):
                init_val = {}
                for name in ES.keys():
                    if name.startswith('MQ-'):
                       init_val[name] = sum(d[name] for d in setup_sample_list) / len(setup_sample_list)
                for name in init_val.keys():
                    rover.MQSEN[name].initialCalibration(init_val[name])
                print 'Done Calibrating'
        else:
            try:
                #Build up vehicle state message
                msg = env_data()
                msg.header.stamp = rospy.Time.now()
                msg.MQ4.raw= ES['MQ-4']
                msg.MQ135.raw = ES['MQ-135']
                msg.MQ2.raw = ES['MQ-2']
                msg.MQ5.raw = ES['MQ-5']
                msg.MQ8.raw = ES['MQ-8']
                msg.MQ9.raw = ES['MQ-9']
                msg.MQ7.raw = ES['MQ-7']
                msg.MQ6.raw = ES['MQ-6']

                try:
                    for sen_name in rover.MQSEN.keys():
                        sen_name_mod = re.sub('[-]','',sen_name)

                        mq = msg.__getattribute__(sen_name_mod)
                        mq.__setattr__('sen_name',sen_name)

                        Y = rover.MQSEN[sen_name].processValue(ES[sen_name])
                        for sub in Y:
                            mq.__setattr__(sub,Y[sub])

                        msg.__setattr__(sen_name_mod,mq)

                except Exception, e:
                    traceback.print_exc()
                    rospy.logwarn('Error Generating Calibrated Values')
                    

                msg.Temperature1 = ES['Temp1']
                msg.Temperature2 = ES['Temp2']
                msg.Humidity = ES['Humidity']
                msg.Particulate = ES['Particulate']
                pub.publish(msg)

            except Exception, err:
                rospy.logwarn('Could Not Publish Env Data');
                rospy.logwarn(err)

        rate.sleep()
\end{verbatim}


\section{Sensor Calibration}
\begin{verbatim}
import sqlite3 as lite
import math
import sys

class MQ:

    con = None

    def __init__(self,calibration_path,name):
       self.calpath = calibration_path
       self.name = name;

       try:
         con = lite.connect(self.calpath)

         cur = con.cursor()

         query = 'SELECT sub.Name,Intercept,C,M,sen.R2,sen.Cair FROM Calibration AS cal INNER JOIN Substances AS sub ON cal.SubstanceID=sub.id INNER JOIN Sensors AS sen ON cal.SensorID=sen.id WHERE sen.name="' + self.name + '";'

         result = cur.execute(query)
         colname = [ d[0] for d in result.description ]
         self.calibrations = [ dict(zip(colname, r)) for r in result.fetchall() ]
         con.close()
       except lite.Error, e:
           print "Error %s:" % e.args[0]
           sys.exit(0)

       finally:
            if con:
                con.close()

    def initialCalibration(self,raw_val):
        self.R2 = self.calibrations[0]['R2'] 
        Cair = self.calibrations[0]['Cair']
        Vm = raw_val * (5.0 / 1023.0)
        self.R0 = self.R2*(5.0 - Vm) / (Cair * Vm)
        return

    def processValue(self,raw_val):
        Vm = raw_val * (5.0 / 1023.0)
        try:
            Rs = self.R2*(5.0-Vm)/Vm        
        except ZeroDivisionError, e:
            print( 'Zero Division Error Caught' )
            Rs = 0
        Y = dict()
        for x in self.calibrations: 
            C = float(x['C'])
            M = float(x['M'])
            name = str(x['Name'])
            try:
                Y[name] = math.pow(C*(Rs/self.R0),M)
            except ValueError, e:
                print 'Math Error Caught'
                Y[name] = 0
        return Y

if __name__ == '__main__':
    MQ1 = MQ('mqdb.sqlite','MQ-4')
    MQ1.initialCalibration(128)
    print MQ1.processValue(255)
\end{verbatim}


\section{Laser Startup}
\begin{verbatim}
<launch>
	<!-- Start the robot model which includes visual geometery and
	     static transformations which define the robot's
	     different frames -->	
        <env name="ROSCONSOLE_FORMAT" value="[${thread}] [${node}/${function}:${line}]: ${message}"/>

	<param name="use_sim_time" value="false" />
	<include file="$(find rsl_rover)/launch/robot_state.launch" />

	<!-- Connect to the Vehicle Mega -->
	<include file="$(find rsl_rover)/launch/rover_interface.launch" /> 

	<!-- Startup all of the sensors: Lidar, GPS, IMU, Cameras -->
	<include file="$(find rsl_rover)/launch/RSL_LMS221.launch" /> 
	<include file="$(find rsl_rover)/launch/lms221_filter.launch" />
	<include file="$(find rsl_rover)/launch/RSL_LMS111.launch" />
	<include file="$(find rsl_rover)/launch/novatel.launch" />
	<include file="$(find rsl_rover)/launch/um7.launch" />
	<!--<include file="$(find rsl_rover)/launch/cameras.launch" /> -->


	<!-- Startup all of the mapping & localization nodes -->
	<include file="$(find rsl_rover)/launch/hector.launch" />
	<!--<include file="$(find rsl_rover)/launch/octomap.launch" />-->
        <include file="$(find rsl_rover)/launch/loc.launch" />

	<!-- Startup RVIZ visualization, marked as required so
	      all nodes will exit if rviz is closed -->
	<include file="$(find rsl_rover)/launch/rover_rviz.launch" />

	<!-- Startup Web Services -->
	<!--	<include file="$(find rsl_rover)/launch/serv.launch" /> -->
</launch>
\end{verbatim}


\section{LIDAR LMS111 Launch}
\begin{verbatim}
<launch>
  <arg name="host" default="10.0.0.140" />
  <node pkg="lms1xx" name="lms1xx" type="LMS1xx_node" output="screen">
    <param name="host" value="$(arg host)" />
    <param name="frame_id" value="front_laser" />
  </node>
  <include file="$(find rsl_rover)/launch/scan_filter.launch" />
</launch>
\end{verbatim}


\section{LIDAR LMS221 Launch}
\begin{verbatim}
<launch>
	<node pkg="rsl_rover" name="gimbal_driver" type="gimbal_driver.py" output="screen">
  </node>
  <node pkg="sicktoolbox_wrapper" name="lms221" type="sicklms">
	<param name="port" value="/dev/lms221" />
	<param name="baud" value="500000" />
	<param name="frame_id" value="gimbal_laser" />
	<remap from="scan" to="scanlms221" /> 
  </node>
</launch>
\end{verbatim}

\section{LIDAR LMS221 Filter Launch}
\begin{verbatim}
<launch>
	<node pkg="rsl_rover" type="periodic_snapshotter2" name="rover_periodic_snapshotter2" />

	<!-- Filter the point cloud with a Voxel Fliter Nodelet -->
	  <node pkg="nodelet" type="nodelet" name="pcl_manager" args="manager" output="screen" />
	  <!-- Run a VoxelGrid filter to clean NaNs and downsample the data -->
	  <node pkg="nodelet" type="nodelet" name="voxel_grid" args="load pcl/VoxelGrid pcl_manager" output="screen">
		<remap from="~input" to="assembled_cloud" />
		<remap from="~output" to="filtered_cloud" />
		<rosparam command="load" file="$(find rsl_rover)/filter_config/voxel_config.yaml" />
	  </node>
</launch>
\end{verbatim}


\section{All Laser Launch}
\begin{verbatim}
<launch>
	<include file="RSL_LMS221.launch" />
	<include file="RSL_LMS111.launch" />
	<node pkg="laser_assembler" name="laser_scan_assembler" type="laser_scan_assembler" >
		<param name="max_scans" type="int" value="400" />
		<param name="fixed_frame" type="string" value="base_link" />
	</node>
</launch>
\end{verbatim}

\section{Hector Mapping Launch}
\begin{verbatim}
<launch>
  <arg name="tf_map_scanmatch_transform_frame_name" default="scanmatcher_frame"/>
  <arg name="base_frame" default="base_link"/>
  <arg name="odom_frame" default="odom"/>
  <arg name="pub_map_odom_transform" default="false"/>
  <arg name="scan_subscriber_queue_size" default="5"/>
  <arg name="scan_topic" default="scan"/>
  <arg name="map_size" default="4096"/>

  <!--  <node pkg="topic_tools" type="relay" name="scan_relay_1" args="scanlms221 scan_total" />
  <node pkg="topic_tools" type="relay" name="scan_relay_2" args="scan scan_total" /> -->
  
  <node pkg="hector_mapping" type="hector_mapping" name="hector_mapping" output="screen">
    <param name="laser_max_dist" value="140.0" />
    
    <!-- Frame names -->
    <param name="map_frame" value="map" />
    <param name="base_frame" value="$(arg base_frame)" />
    <param name="odom_frame" value="$(arg odom_frame)" />
    
    <!-- Tf use -->
    <param name="use_tf_scan_transformation" value="true"/>
    <param name="use_tf_pose_start_estimate" value="false"/>
    <param name="pub_map_odom_transform" value="$(arg pub_map_odom_transform)"/>
    
    <!-- Map size / start point -->
    <param name="map_resolution" value="0.20"/>
    <param name="map_size" value="$(arg map_size)"/>
    <param name="map_start_x" value="0.5"/>
    <param name="map_start_y" value="0.5" />
    <param name="map_multi_res_levels" value="3" />
    
    <!-- Map update parameters -->
    <param name="update_factor_free" value="0.4"/>
    <param name="update_factor_occupied" value="0.9" />    
    <param name="map_update_distance_thresh" value="0.1"/>
    <param name="map_update_angle_thresh" value="0.02" />
    <param name="laser_z_min_value" value = "-1.0" />
    <param name="laser_z_max_value" value = "1.5" />
    
    <!-- Advertising config --> 
    <param name="advertise_map_service" value="true"/>
    
    <param name="scan_subscriber_queue_size" value="$(arg scan_subscriber_queue_size)"/>
    <param name="scan_topic" value="$(arg scan_topic)"/>
    
    <!-- Debug parameters -->
    <!--
      <param name="output_timing" value="false"/>
      <param name="pub_drawings" value="true"/>
      <param name="pub_debug_output" value="true"/>
    -->
    <param name="tf_map_scanmatch_transform_frame_name" value="$(arg tf_map_scanmatch_transform_frame_name)" />
  </node>
    
</launch>
  
\end{verbatim}


\section{Localization Launch}
\begin{verbatim}

<!-- Launch file for ekf_localization_node -->

<!-- Layer 1 Localization: Odometry Frame -->
<launch>
    <node pkg="tf" type="static_transform_publisher" name="tach_odom123" args="0 0 0 0 0 0 1 odom tach_odom 20" />
    <node pkg="rsl_rover" type="imu_override_covariance.py" name="IOC" />
    <!--    <node pkg="rsl_rover" type="virt_yaw_sensor.py" name="VirtYaw" output="screen"/> -->

    <node pkg="imu_complementary_filter" type="complementary_filter_node" name="complementary_filter_node" >
	   <remap from="imu/data_raw" to="imu/data_cov" />
	   <remap from="imu/mag" to="imu/mag" />
	   <remap from="imu/data" to="imu/data_filtered" />
	   <param name="do_bias_estimation" value="true"/>
	   <param name="do_adaptive_gain" value="true"/>
	   <param name="use_mag" value="false"/>
	   <param name="gain_acc" value="0.01"/>
	   <param name="gain_mag" value="0.01"/>
    </node>

    <node pkg="robot_localization" type="ekf_localization_node" name="odom_localization" clear_params="true" output="screen">

      <param name="frequency" value="30"/>
      <param name="sensor_timeout" value="0.1"/>
      <param name="two_d_mode" value="true"/>
      <param name="map_frame" value="map"/>
      <param name="odom_frame" value="odom"/>
      <param name="base_link_frame" value="base_link"/>
      <param name="world_frame" value="odom"/>
      <param name="transform_time_offset" value="0.0"/>

      <!-- The filter accepts an arbitrary number of inputs from each input message type (Odometry, PoseStamped,
           TwistStamped, Imu). To add a new one, simply append the next number in the sequence to its base name,
           e.g., odom0, odom1, twist0, twist1, imu0, imu1, imu2, etc. The value should be the topic name. These
           parameters obviously have no default values, and must be specified. -->
      <param name="odom0" value="/VehicleTach"/>
      <!--      <param name="odom1" value="/VirtYaw"/> -->
      <param name="imu0" value="/imu/data_filtered"/>

      <!-- Each sensor reading updates some or all of the filter's state. These options give you greater control over
           which values from each measurement /imu/data_filteredare fed to the filter. For example, if you have an odometry message as input,
           but only want to use its Z position value, then set the entire vector to false, except for the third entry.
           The order of the values is x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az. Note that not some
           message types lack certain variables. For example, a TwistWithCovarianceStamped message has no pose information, so
           the first six values would be meaningless in that case. Each vector defaults to all false if unspecified, effectively
           making this parameter required for each sensor. -->

      <rosparam param="odom0_config">[false, false, false,
                                      false, false, false,
                                      true,  true, false,
                                      false, false, true,
                                      false, false, false]</rosparam> -->
<!--      <rosparam param="odom1_config">[false, false, false,
                                      false, false, false,
                                      false,  false, false,
                                      false, false, true,
                  false, false, false]</rosparam> -->

      <rosparam param="imu0_config">[false, false, false,
                                     true,  true,  true,
                                     false, false, false,
                                     true,  true,  true,
                                     false,  false,  false]</rosparam>

      <!-- The best practice for including new sensors in robot_localization's state estimation nodes is to pass in velocity
           measurements and let the nodes integrate them. However, this isn't always feasible, and so the state estimation
           nodes support fusion of absolute measurements. If you have more than one sensor providing absolute measurements,
           however, you may run into problems if your covariances are not large enough, as the sensors will inevitably
           diverge from one another, causing the filter to jump back and forth rapidly. To combat this situation, you can
           either increase the covariances for the variables in question, or you can simply set the sensor's differential
           parameter to true. When differential mode is enabled, all absolute pose data is converted to velocity data by
           differentiating the absolute pose measurements. These velocities are then integrated as usual. NOTE: this only
           applies to sensors that provide absolute measurements, so setting differential to true for twit measurements has
           no effect.

           Users should take care when setting this to true for orientation variables: if you have only one source of
           absolute orientation data, you should not set the differential parameter to true. This is due to the fact that
           integration of velocities leads to slowly increasing error in the absolute (pose) variable. For position variables,
           this is acceptable. For orientation variables, it can lead to trouble. Users should make sure that all orientation
           variables have at least one source of absolute measurement. -->
      <param name="odom0_differential" value="false"/>
      <!--      <param name="odom1_differential" value="false"/> -->
      <param name="imu0_differential" value="false"/>

      <!-- When the node starts, if this parameter is true, then the first measurement is treated as a "zero point" for all
           future measurements. While you can achieve the same effect with the differential paremeter, the key difference is
           that the relative parameter doesn't cause the measurement to be converted to a velocity before integrating it. If
           you simply want your measurements to start at 0 for a given sensor, set this to true. -->
      <param name="odom0_relative" value="false"/>
      <!--      <param name="odom1_relative" value="false"/> -->
      <param name="imu0_relative" value="false"/>

      <!-- If we're including accelerations in our state estimate, then we'll probably want to remove any acceleration that
           is due to gravity for each IMU. If you don't want to, then set this to false. Defaults to false if unspecified. -->
      <param name="imu0_remove_gravitational_acceleration" value="true"/>

      <!-- If you're having trouble, try setting this to true, and then echo the /diagnostics_agg topic to see
           if the node is unhappy with any settings or data. -->
      <param name="print_diagnostics" value="true"/>

      <!-- ======== ADVANCED PARAMETERS ======== -->

      <!-- Most users will be able to remove these parameters from the launch file without any consequences. We recommend
           that users do not set values for these parameters without having a thorough understanding of
           the parameters do. -->

      <!-- By default, the subscription queue size for each message type is 1. If you wish to increase that so as not
           miss any messages (even if your frequency is set to a relatively small value), increase these. -->
      <param name="odom0_queue_size" value="2"/>
      <!--<param name="odom1_queue_size" value="2"/> -->
      <param name="imu0_queue_size" value="2"/>

      <!-- If your data is subject to outliers, use these threshold settings, expressed as Mahalanobis distances, to control
           how far away from the current vehicle state a sensor measurement is permitted to be. Each defaults to
           numeric_limits<double>::max() if unspecified. -->
      <!--      <param name="odom1_pose_rejection_threshold" value="5"/>
      <param name="odom1_twist_rejection_threshold" value="1"/> -->
      <!--<param name="imu0_pose_rejection_threshold" value="0.3"/>
      <param name="imu0_twist_rejection_threshold" value="0.1"/>
      <param name="imu0_linear_acceleration_rejection_threshold" value="0.1"/> -->

      <!-- Debug settings. Not for the faint of heart. Outputs a ludicrous amount of information to the file
           specified by debug_out_file. I hope you like matrices! Defaults to false if unspecified. -->
      <param name="debug"           value="false"/>
      <!-- Defaults to "robot_localization_debug.txt" if unspecified. -->
      <param name="debug_out_file"  value="debug_ekf_localization.txt"/>

      <!-- The process noise covariance matrix can be difficult to tune, and can vary for each application, so it
           is exposed as a configuration parameter. The values are ordered as x, y, z, roll, pitch, yaw, vx, vy, vz,
           vroll, vpitch, vyaw, ax, ay, az. Defaults to the matrix below if unspecified. -->
      <rosparam param="process_noise_covariance">[0.05, 0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0.05, 0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0.06, 0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0.03, 0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0.03, 0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0.06, 0,     0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0.025, 0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0.025, 0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0.04, 0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0.01, 0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0.01, 0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0.02, 0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0.01, 0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0.01, 0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0.015]</rosparam>

      <!-- This represents the initial value for the state estimate error covariance matrix. Setting a diagonal value (a
           variance) to a large value will result in early measurements for that variable being accepted quickly. Users should
           take care not to use large values for variables that will not be measured directly. The values are ordered as x, y,
           z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az. Defaults to the matrix below if unspecified. -->
           <rosparam param="initial_estimate_covariance">[1e-9, 0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    1e-9, 0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    1e-9, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    1e-9, 0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    1e-9, 0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    1e-9, 0,    0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    1e-9, 0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    1e-9, 0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    1e-9, 0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    0,    1e-9,  0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     1e-9,  0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     1e-9,  0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     1e-9, 0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    1e-9, 0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    1e-9]</rosparam>


  <!--  Placeholder for output topic remapping-->
  <remap from="odometry/filtered" to="odometry/filtered_cont"/>
      
    </node>
    

    <node pkg="robot_localization" type="navsat_transform_node" name="navsat_transform_node">
      <param name="magnetic_declination_radians" value="0.236"/>
      <param name="yaw_offset" value="0"/>
      <!--      <param name="yaw_offset" value="1.5707963"/>-->
      <param name="publish_filtered_gps" value="true" />
      <param name="broadcast_utm_transform" value="true" />

      <remap from="/imu/data" to="/imu/data_filtered" />
      <remap from="/gps/fix" to="/fix" />
      <remap from="/odometry/filtered" to="/odometry/filtered_discont" />
    </node>


<!-- Layer 2 Localization: Map Frame -->
    <node pkg="robot_localization" type="ekf_localization_node" name="map_localization" clear_params="true" output="screen">

      <param name="frequency" value="30"/>
      <param name="sensor_timeout" value="0.1"/>
      <param name="two_d_mode" value="true"/>

      <param name="map_frame" value="map"/>
      <param name="odom_frame" value="odom"/>
      <param name="base_link_frame" value="base_link"/>
      <param name="world_frame" value="map"/>

      <param name="transform_time_offset" value="0.0"/>

      <param name="odom0" value="/odometry/filtered_cont"/>
      <param name="pose0" value="/poseupdate"/>

      <rosparam param="odom0_config">[false, false, false,
                                      false, false, false,
                                      true,  true, false,
                                      false, false, true,
                                      true, true, false]</rosparam> -->

      <rosparam param="pose0_config">[true, true, false,
                                      false, false, true,
                                      false,  false, false,
                                      false, false, false,
                                      false, false, false]</rosparam> -->

      <param name="odom0_differential" value="false"/>
      <param name="odom0_relative" value="false"/>
      <param name="pose0_differential" value="false"/>
      <param name="pose0_relative" value="false"/>

      <!-- If you're having trouble, try setting this to true, and then echo the /diagnostics_agg topic to see
           if the node is unhappy with any settings or data. -->
      <param name="print_diagnostics" value="true"/>

      <!-- ======== ADVANCED PARAMETERS ======== -->

      <!-- Most users will be able to remove these parameters from the launch file without any consequences. We recommend
           that users do not set values for these parameters without having a thorough understanding of
           the parameters do. -->

      <!-- By default, the subscription queue size for each message type is 1. If you wish to increase that so as not
           miss any messages (even if your frequency is set to a relatively small value), increase these. -->
      <param name="odom0_queue_size" value="1"/>
      <param name="pose0_queue_size" value="1"/>

      <!-- If your data is subject to outliers, use these threshold settings, expressed as Mahalanobis distances, to control
           how far away from the current vehicle state a sensor measurement is permitted to be. Each defaults to
           numeric_limits<double>::max() if unspecified. -->
<!--      <param name="odom0_pose_rejection_threshold" value="5"/>
      <param name="odom0_twist_rejection_threshold" value="1"/> -->

      <!-- Debug settings. Not for the faint of heart. Outputs a ludicrous amount of information to the file
           specified by debug_out_file. I hope you like matrices! Defaults to false if unspecified. -->
      <param name="debug"           value="false"/>
      <!-- Defaults to "robot_localization_debug.txt" if unspecified. -->
      <param name="debug_out_file"  value="debug_ekf_localization.txt"/>

      <!-- The process noise covariance matrix can be difficult to tune, and can vary for each application, so it
           is exposed as a configuration parameter. The values are ordered as x, y, z, roll, pitch, yaw, vx, vy, vz,
           vroll, vpitch, vyaw, ax, ay, az. Defaults to the matrix below if unspecified. -->
      <rosparam param="process_noise_covariance">[0.05, 0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0.05, 0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0.06, 0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0.03, 0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0.03, 0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0.06, 0,     0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0.025, 0,     0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0.025, 0,    0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0.04, 0,    0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0.01, 0,    0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0.01, 0,    0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0.02, 0,    0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0.01, 0,    0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0.01, 0,
                                                  0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0.015]</rosparam>

      <!-- This represents the initial value for the state estimate error covariance matrix. Setting a diagonal value (a
           variance) to a large value will result in early measurements for that variable being accepted quickly. Users should
           take care not to use large values for variables that will not be measured directly. The values are ordered as x, y,
           z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az. Defaults to the matrix below if unspecified. -->
           <rosparam param="initial_estimate_covariance">[1e-9, 0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    1e-9, 0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    1e-9, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    1e-9, 0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    1e-9, 0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    1e-9, 0,    0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    1e-9, 0,    0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    1e-9, 0,    0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    1e-9, 0,     0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    0,    1e-9,  0,     0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     1e-9,  0,     0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     1e-9,  0,    0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     1e-9, 0,    0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    1e-9, 0,
                                                          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    1e-9]</rosparam>


  <!--  Placeholder for output topic remapping-->
  <remap from="odometry/filtered" to="odometry/filtered_discont"/>
      

    </node>
    
</launch>

\end{verbatim}


\section{Map Testing Launch}
\begin{verbatim}
<launch> 
	<!-- Plays back data from bagfile and uses simualtion clock -->
	<arg name="bagfile" default="$(find rsl_rover)/bag/jan25-rover-maneuvering.bag" />
	<param name="use_sim_time" value="true" />
	<node pkg="rosbag" type="play" name="rosbag" args="--clock $(arg bagfile)" required="true">
	</node>

	<!-- Static transforms in place of odometry. Assumes stationary robot -->
	<node pkg="tf" type="static_transform_publisher" name="stationary_robot_transform" args="0 0 0 0 0 0 /base_link /map 100"/>
	<node pkg="tf" type="static_transform_publisher" name="stationary_robot_transform_1" args="0 0 0 0 0 0 /base_link /odom 100"/>

	<!-- Assemble the laser scans into a point cloud, published periodically -->
	<node pkg="laser_assembler" type="laser_scan_assembler" name="rover_laser_assembler" >
		<param name="fixed_frame" type="string" value="base_link" />
	</node>
	<node pkg="rsl_rover" type="periodic_snapshotter" name="rover_periodic_snapshotter" output="screen">
		<param name="pub_duration" value="1.0" />
	</node>

	<!-- Filter the point cloud with a Voxel Fliter Nodelet -->
	  <node pkg="nodelet" type="nodelet" name="pcl_manager" args="manager" output="screen" />
	  <!-- Run a VoxelGrid filter to clean NaNs and downsample the data -->
	  <node pkg="nodelet" type="nodelet" name="voxel_grid" args="load pcl/VoxelGrid pcl_manager" output="screen">
		<remap from="~input" to="assembled_cloud" />
		<remap from="~output" to="filtered_cloud" />
		<rosparam command="load" file="$(find rsl_rover)/filter_config/voxel_config.yaml" />
	  </node>

	<!-- Alternative Filter Method -->
	<!--
	<node pkg="laser_filters" type="scan_to_cloud_filter_chain" name="scan2cloud" >
		<rosparam command="load" file="$(find rsl_rover)/filter_config/laser_config.yaml" />
		<rosparam command="load" file="$(find rsl_rover)/filter_config/cloud_config.yaml" />
		<param name="high_fidelity" value="false" />
		<param name="target_frame" type="string" value="base_link" />
	</node>
-->

	<node pkg="octomap_server" type="octomap_server_node" name="rover_octomap_server" output="screen" >
		<remap from="cloud_in" to="filtered_cloud" />
		<param name="resolution"  value="0.3" />
		<param name="filter_ground" value="false" />
		<param name="latch" value="false" />
		<param name="base_frame_id" value="base_footprint" />
		<param name="ground_filter/distance" value="0.04" />
		<param name="ground_filter/angle" value="0.15" />
		<param name="ground_filter/plane_distance" value="0.07" />
	</node>

	<include file="$(find rsl_rover)/launch/robot_state.launch" />
	<include file="$(find rsl_rover)/launch/rover_rviz.launch" />
</launch>
\end{verbatim}



\section{Navigation Stack Move Base Launch}
\begin{verbatim}
<launch>
	<!-- Optionally run something like AMCL -->

	<!-- run Navigation Stack Move Base -->
  	<node pkg="move_base" type="move_base" respawn="false" name="move_base" output="screen">
	    <rosparam file="$(find rsl_rover)/cfg/costmap_common_params.yaml" command="load" ns="global_costmap" />
	    <rosparam file="$(find rsl_rover)/cfg/costmap_common_params.yaml" command="load" ns="local_costmap" />
	    <rosparam file="$(find rsl_rover)/cfg/local_costmap_params.yaml" command="load" />
	    <rosparam file="$(find rsl_rover)/cfg/global_costmap_params.yaml" command="load" />
	    <rosparam file="$(find rsl_rover)/cfg/teb_local_planner_params.yaml" command="load" />
	    <rosparam file="$(find rsl_rover)/cfg/costmap_converter_params.yaml" command="load" /> <!-- Enable to activate costmap_conversion plugins -->
	    <param name="base_local_planner" value="teb_local_planner/TebLocalPlannerROS" />
	    <!--param name="base_global_planner" value="straight_global_planner/StraightROS" /-->
	    <param name="controller_frequency" value="5.0" />

	    <remap from="map" to="/map" /> <!-- This file will be wrapped with namespace so we have to remove namespace from all appearances of map (there is only one map) -->
	    <remap from="move_base_simple/goal" to="/move_base_simple/goal"/> <!-- We have only a single robot now, that is controlled via goals -->
	    <remap from="odom" to="odometry/filtered_discont" />
 	</node>

	<node pkg="rsl_rover" name="cmd_to_ack" type="cmd_vel_to_ackermann_drive.py">
		<param name="wheelbase" value="2.5" />
		<param name="frame_id" value="odom" />
	</node>
</launch>

\end{verbatim}




\section{OctoMap Launch}
\begin{verbatim}
<launch> 
	<!-- Assemble the laser scans into a point cloud, published periodically -->
	<!-- <node pkg="laser_assembler" type="laser_scan_assembler" name="rover_laser_assembler" >
		<param name="fixed_frame" type="string" value="base_link" />
		<remap from="scan" to="scanlms221" />
	</node> -->

	<!--	<node pkg="rsl_rover" type="periodic_snapshotter" name="rover_periodic_snapshotter">
		<param name="fixed_frame" type="string" value="/odom" />
		<param name="ignore_laser_skew" type="bool" value="false" />	
		<param name="pub_duration" value="1.0" />
	</node>
-->
<!--
	<node pkg="rsl_rover" type="periodic_snapshotter2" name="rover_periodic_snapshotter2" />


	  <node pkg="nodelet" type="nodelet" name="pcl_manager" args="manager" output="screen" />
	  <node pkg="nodelet" type="nodelet" name="voxel_grid" args="load pcl/VoxelGrid pcl_manager" output="screen">
		<remap from="~input" to="assembled_cloud" />
		<remap from="~output" to="filtered_cloud" />
		<rosparam command="load" file="$(find rsl_rover)/filter_config/voxel_config.yaml" />
	  </node>
	  -->
	<!-- Alternative Filter Method -->
	<!--
	<node pkg="laser_filters" type="scan_to_cloud_filter_chain" name="scan2cloud" >
		<rosparam command="load" file="$(find rsl_rover)/filter_config/laser_config.yaml" />
		<rosparam command="load" file="$(find rsl_rover)/filter_config/cloud_config.yaml" />
		<param name="high_fidelity" value="false" />
		<param name="target_frame" type="string" value="base_link" />
	</node>
-->

	<node pkg="octomap_server" type="octomap_server_node" name="rover_octomap_server" output="screen" >
		<remap from="cloud_in" to="filtered_cloud" />
		<param name="resolution"  value="0.2" />
		<param name="filter_ground" value="false" />
		<param name="latch" value="false" />
		<param name="base_frame_id" value="base_footprint" />
		<param name="ground_filter/distance" value="0.04" />
		<param name="ground_filter/angle" value="0.15" />
		<param name="ground_filter/plane_distance" value="0.07" />
	</node>


</launch>
\end{verbatim}


\section{Vehicle State in Map Launch}
\begin{verbatim}
<launch>
	<param name="robot_description" command="cat $(find rsl_rover)/urdf/rsl_roverzoe.urdf" />
	<node name="robot_state_publisher" pkg="robot_state_publisher" type="state_publisher" />
</launch>
\end{verbatim}


\section{Vehicle Interface Launch}
\begin{verbatim}
<launch>
	<node pkg="rsl_rover" name="rover_interface" type="rover_decode.py" required="true" output="screen">
  </node>
</launch>
\end{verbatim}


\section{Vehicle RVIZ Launch}
\begin{verbatim}
<launch>
	<node pkg="rviz" type="rviz" name="rviz" args="-d $(find rsl_rover)/rviz_cfg/rover_driving.rviz" required="true"/>
</launch>
\end{verbatim}


\section{Vehicle Startup Launch}
\begin{verbatim}
<launch>
  <node pkg="myahrs_driver" type="myahrs_driver" name="myahrs_driver">
    <param name="port" value="/dev/ttyACM0" />
    <param name="baud_rate" value="115200" />
  </node>
  <node pkg="nmea_navsat_driver" type="nmea_serial_driver" name="gps_driver">
    <param name="port" value="/dev/ttyS0" />
    <param name="baud_rate" value="9600" />
  </node>
  <node pkg="rviz" type="rviz" name="rviz" args="-d $(find myahrs_driver)/rviz_cfg/imu_test.rviz" />
</launch>

\end{verbatim}



\section{Laser Scan Filter Launch}
\begin{verbatim}
<launch>
  <node pkg="laser_filters" type="scan_to_scan_filter_chain"  name="laser_filter">
    <rosparam command="load" file="$(find rsl_rover)/cfg/my_laser_config.yaml" />
    <remap from="scan" to="scan" />
  </node>
</launch>
\end{verbatim}

\section{UM7 Orientation Sensor Launch}
\begin{verbatim}
<launch>
  <node pkg="um7" type="um7_driver" name="um7_driver">
    <param name="port" value="/dev/um7" />
    <param name="covariance" value=".1 0 0 0 .1 0 0 0 .1" />
    <param name="zero_gyros" value="true" />
  </node>
</launch>
\end{verbatim}



\section{Laser Configuration}
\begin{verbatim}

scan_filter_chain:
- name: shadows
  type: laser_filters/ScanShadowsFilter
  params:
    min_angle: 5
    max_angle: 175
    neighbors: 10
    window: 1
- name: dark_shadows
  type: laser_filters/LaserScanIntensityFilter
  params: 
    lower_threshold: 100
    upper_threshold: 10000
    disp_histogram: 0

\end{verbatim}


\section{Web Server Launch}
\begin{verbatim}
<launch>
  <!--<param name="use_sim_time" value="false" />-->
  <!--
  <node name="camera_web_server" pkg="web_video_server"  type="web_video_server" output="screen">
    <param name="port" value="8080" />
    <param name="address" value="0.0.0.0" />
    <param name="server_threads" value="1" />
    <param name="ros_threads" value="2" />
  </node>
-->

  <arg name="port" default="9090" />
  <arg name="address" default="" />
  <arg name="ssl" default="false" />
  <arg name="certfile" default=""/>
  <arg name="keyfile" default="" />
  <arg name="authenticate" default="false" />

  <group if="$(arg ssl)">
    <node name="rosbridge_websocket" pkg="rosbridge_server" type="rosbridge_websocket" output="screen">
      <param name="certfile" value="$(arg certfile)" />
      <param name="keyfile" value="$(arg keyfile)" />
      <param name="authenticate" value="$(arg authenticate)" />
      <param name="port" value="$(arg port)"/>
      <param name="address" value="$(arg address)"/>
    </node>
  </group>
  <group unless="$(arg ssl)">
    <node name="rosbridge_websocket" pkg="rosbridge_server" type="rosbridge_websocket" output="screen">
      <param name="authenticate" value="$(arg authenticate)" />
      <param name="port" value="$(arg port)"/>
      <param name="address" value="$(arg address)"/>
    </node>
  </group>

  <node name="rosapi" pkg="rosapi" type="rosapi_node" />

</launch>
\end{verbatim}




\section{User Interface Control Center Main}
\begin{verbatim}
'use strict';

function ROSCCConfig($routeProvider, localStorageServiceProvider) {
  $routeProvider.when('/', {
    templateUrl: 'app/control/control.html',
    controller: 'ControlController',
    controllerAs: 'vm'
  }).when('/settings', {
    templateUrl: 'app/settings/settings.html',
    controller: 'SettingsController',
    controllerAs: 'vm'
  }).otherwise({ redirectTo: '/' });

  localStorageServiceProvider.setPrefix('roscc');
}

angular.module('roscc', ['ngRoute', 'ui.bootstrap', 'LocalStorageModule']).config(ROSCCConfig);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ros = undefined;
var isConnected = false;

var ControlController = function () {
  function ControlController($timeout, $interval, Settings, Domains) {
    var _this = this;

    _classCallCheck(this, ControlController);

    this.$timeout = $timeout;
    this.Domains = Domains;

    this.isConnected = isConnected;
    this.setting = Settings.get();
    this.maxConsoleEntries = 200;

    // Load ROS connection and keep trying if it fails
    this.newRosConnection();
    $interval(function () {
      _this.newRosConnection();
    }, 1000); // [ms]

    this.resetData();
    if (isConnected) {
      this.onConnected();
    }
  }

  // The active domain shows further information in the center view

  _createClass(ControlController, [{
    key: 'setActiveDomain',
    value: function setActiveDomain(domain) {
      this.activeDomain = domain;
    }
  }, {
    key: 'getDomains',
    value: function getDomains() {
      var allData = this.data.topics.concat(this.data.services, this.data.nodes);
      var domains = this.Domains.getDomains(allData);
      if (!this.activeDomain) {
        // if no other domains are found, use Dashboard as the default
        this.setActiveDomain('Dashboard');
      }
      return domains;
    }
  }, {
    key: 'getGlobalParameters',
    value: function getGlobalParameters() {
      return this.Domains.getGlobalParameters(this.data.parameters);
    }
  }, {
    key: 'resetData',
    value: function resetData() {
      this.data = {
        rosout: [],
        topics: [],
        nodes: [],
        parameters: [],
        services: []
      };
    }
  }, {
    key: 'newRosConnection',
    value: function newRosConnection() {
      var _this2 = this;

      if (isConnected || !this.setting) {
        return;
      }

      if (ros) {
        ros.close(); // Close old connection
        ros = false;
        return;
      }

      ros = new ROSLIB.Ros({ url: 'ws://' + this.setting.address + ':' + this.setting.port });

      ros.on('connection', function () {
        _this2.onConnected();
        isConnected = true;
        _this2.isConnected = isConnected;
      });

      ros.on('error', function () {
        isConnected = false;
        _this2.isConnected = isConnected;
      });

      ros.on('close', function () {
        isConnected = false;
        _this2.isConnected = isConnected;
      });
    }
  }, {
    key: 'onConnected',
    value: function onConnected() {
      var _this3 = this;

      console.log("Connected!");

      // wait a moment until ROS is loaded and initialized
      this.$timeout(function () {
        _this3.loadData();

        _this3.setConsole();
        if (_this3.setting.battery) {
          _this3.setBattery();
        }
      }, 1000); // [ms]
    }

    // Setup of console (in the right sidebar)

  }, {
    key: 'setConsole',
    value: function setConsole() {
      var _this4 = this;

      var consoleTopic = new ROSLIB.Topic({
        ros: ros,
        name: this.setting.log,
        messageType: 'rosgraph_msgs/Log'
      });
      consoleTopic.subscribe(function (message) {
        var nameArray = message.name.split('/');
        var d = new Date(message.header.stamp.secs * 1E3 + message.header.stamp.nsecs * 1E-6);

        message.abbr = nameArray.length > 1 ? nameArray[1] : message.name;

        // String formatting of message time and date
        function addZero(i) {
          return i < 10 ? '0' + i : i;
        }
        message.dateString = addZero(d.getHours()) + ':' + addZero(d.getMinutes()) + ':' + addZero(d.getSeconds()) + '.' + addZero(d.getMilliseconds());
        _this4.data.rosout.unshift(message);

        if (_this4.data.rosout.length > _this4.maxConsoleEntries) {
          _this4.data.rosout.pop();
        }
      });
    }

    // Setup battery status

  }, {
    key: 'setBattery',
    value: function setBattery() {
      var _this5 = this;

      var batteryTopic = new ROSLIB.Topic({
        ros: ros,
        name: this.setting.batteryTopic,
        messageType: 'std_msgs/Float32'
      });
      batteryTopic.subscribe(function (message) {
        _this5.batteryStatus = message.data;
      });
    }

    // Load structure, all data, parameters, topics, services, nodes...

  }, {
    key: 'loadData',
    value: function loadData() {
      var _this6 = this;

      this.resetData();

      ros.getTopics(function (topics) {
        angular.forEach(topics, function (name) {
          _this6.data.topics.push({ name: name });
          console.log("Getting topic: ", name);
          ros.getTopicType(name, function (type) {
            _.findWhere(_this6.data.topics, { name: name }).type = type;
          });
        });
      });

      ros.getServices(function (services) {
        angular.forEach(services, function (name) {
          _this6.data.services.push({ name: name });

          ros.getServiceType(name, function (type) {
            _.findWhere(_this6.data.services, { name: name }).type = type;
          });
        });
      });

      ros.getParams(function (params) {
        angular.forEach(params, function (name) {
          var param = new ROSLIB.Param({ ros: ros, name: name });
          _this6.data.parameters.push({ name: name });

          param.get(function (value) {
            _.findWhere(_this6.data.parameters, { name: name }).value = value;
          });
        });
      });

      ros.getNodes(function (nodes) {
        angular.forEach(nodes, function (name) {
          _this6.data.nodes.push({ name: name });
        });
      });
    }
  }]);

  return ControlController;
}();

angular.module('roscc').controller('ControlController', ControlController);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DomainsService = function () {
  function DomainsService() {
    _classCallCheck(this, DomainsService);
  }

  _createClass(DomainsService, [{
    key: 'filterAdvanced',
    value: function filterAdvanced(entry, advanced) {
      var entryArray = entry.split('/');
      if (advanced) {
        return true;
      }
      if (!entry || _.isEmpty(entryArray)) {
        return false;
      }
      return _.last(entryArray)[0] === _.last(entryArray)[0].toUpperCase();
    }
  }, {
    key: 'getDomains',
    value: function getDomains(array) {
      var result = [];
      angular.forEach(array, function (entry) {
        var nameArray = entry.name.split('/');
        if (nameArray.length > 1) {
          result.push(nameArray[1]);
        }
      });
      return _.uniq(result).sort();
    }
  }, {
    key: 'getGlobalParameters',
    value: function getGlobalParameters(array) {
      var result = [];
      angular.forEach(array, function (entry) {
        var nameArray = entry.name.split('/');
        if (nameArray.length === 2) {
          entry.abbr = _.last(nameArray);
          result.push(entry);
        }
      });
      return result;
    }
  }, {
    key: 'getDataForDomain',
    value: function getDataForDomain(array, domainName, advanced) {
      var _this = this;

      var result = [];

      angular.forEach(array, function (entry) {
        var nameArray = entry.name.split('/');
        if (nameArray.length > 1 && nameArray[1] === domainName && _this.filterAdvanced(entry.name, advanced)) {
          entry.abbr = nameArray.slice(2).join(' ');
          result.push(entry);
        }
      });
      return result;
    }
  }]);

  return DomainsService;
}();

// Filter advanced topics, services, parameters by checking the beginning capital letter

angular.module('roscc').service('Domains', DomainsService);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var QuaternionsService = function () {
  function QuaternionsService() {
    _classCallCheck(this, QuaternionsService);
  }

  _createClass(QuaternionsService, [{
    key: 'getRoll',
    value: function getRoll(q) {
      if (!q) {
        return '';
      }
      var rad = Math.atan2(2 * (q.w * q.x + q.y * q.z), 1 - 2 * (q.x * q.x + q.y * q.y));
      return 180 / Math.PI * rad;
    }
  }, {
    key: 'getPitch',
    value: function getPitch(q) {
      if (!q) {
        return '';
      }
      var rad = Math.asin(2 * (q.w * q.y - q.z * q.x));
      return 180 / Math.PI * rad;
    }
  }, {
    key: 'getYaw',
    value: function getYaw(q) {
      if (!q) {
        return '';
      }
      var rad = Math.atan2(2 * (q.w * q.z + q.x * q.y), 1 - 2 * (q.y * q.y + q.z * q.z));
      return 180 / Math.PI * rad;
    }
  }, {
    key: 'getInit',
    value: function getInit() {
      return { w: 1, x: 0, y: 0, z: 0 };
    }
  }]);

  return QuaternionsService;
}();

// Quaternions to Euler angles converter

angular.module('roscc').service('Quaternions', QuaternionsService);
'use strict';

function NavbarDirective($location) {
  return {
    templateUrl: 'app/navbar/navbar.html',
    controllerAs: 'vm',
    controller: function controller() {
      this.isPath = isPath;

      function isPath(path) {
        return $location.path() === path;
      }
    }
  };
}

angular.module('roscc').directive('ccNavbar', NavbarDirective);
'use strict';

function ParamaterDirective() {
  return {
    scope: { parameter: '=' },
    templateUrl: 'app/parameters/parameters.html',
    controllerAs: 'vm',
    controller: function controller($scope) {
      var param = new ROSLIB.Param({ ros: ros, name: $scope.parameter.name });

      this.parameter = $scope.parameter;
      this.setValue = setValue;

      function setValue(value) {
        param.set(value);
      }
    }
  };
}

angular.module('roscc').directive('ccParameter', ParamaterDirective);
'use strict';

function serviceDirective() {
  return {
    scope: { service: '=' },
    template: '<ng-include src=\"vm.fileName\"></ng-include>',
    controllerAs: 'vm',
    controller: function controller($scope, $timeout, $http) {
      var _this = this;

      var path = 'app/services/';

      this.service = $scope.service;
      this.callService = callService;
      this.fileName = path + 'default.html';

      // Check if file exists
      $scope.$watch('service.type', function () {
        if (!$scope.service.type) {
          return;
        }
        var fileName = path + $scope.service.type + '.html';

        _this.service = $scope.service;
        $http.get(fileName).then(function (result) {
          if (result.data) {
            _this.fileName = fileName;
          }
        });
      });

      function callService(input, isJSON) {
        var _this2 = this;

        var data = isJSON ? angular.fromJSON(input) : input;
        var service = new ROSLIB.Service({
          ros: ros,
          name: this.service.name,
          serviceType: this.service.type
        });
        var request = new ROSLIB.ServiceRequest(data);
        service.callService(request, function (result) {
          $timeout(function () {
            _this2.result = result;
          });
        });
      }
    }
  };
}

angular.module('roscc').directive('ccService', serviceDirective);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SettingsController = function () {
  function SettingsController(localStorageService, Settings) {
    _classCallCheck(this, SettingsController);

    this.Settings = Settings;

    this.settings = Settings.getSettings() || [Settings.getDefaultSetting()];
    this.index = Settings.getIndex();

    if (!this.index || this.index > this.settings.length) {
      this.index = '0';
    }
  }

  _createClass(SettingsController, [{
    key: 'save',
    value: function save() {
      this.Settings.save(this.settings, this.index);
    }
  }, {
    key: 'add',
    value: function add() {
      this.settings.push(this.Settings.getDefaultSetting()); // Clone object
      this.index = String(this.settings.length - 1);
      this.save();
    }
  }, {
    key: 'remove',
    value: function remove() {
      this.settings.splice(this.index, 1);
      this.index = '0';

      if (!this.settings.length) {
        this.add();
      }
      this.save();
    }
  }]);

  return SettingsController;
}();

angular.module('roscc').controller('SettingsController', SettingsController);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SettingsService = function () {
  function SettingsService($location, localStorageService) {
    _classCallCheck(this, SettingsService);

    this.$location = $location;
    this.localStorageService = localStorageService;
  }

  _createClass(SettingsService, [{
    key: 'load',
    value: function load() {
      this.index = this.localStorageService.get('selectedSettingIndex');
      this.settings = this.localStorageService.get('settings');
      if (this.settings && this.index) {
        this.setting = this.settings[this.index];
      }

      // If there are no saved settings, redirect to /settings for first setting input
      if (!this.setting) {
        this.$location.path('/settings').replace();
      }
    }
  }, {
    key: 'save',
    value: function save(newSettings, newIndex) {
      this.settings = newSettings;
      this.index = newIndex;
      this.localStorageService.set('selectedSettingIndex', newIndex);
      this.localStorageService.set('settings', newSettings);
    }
  }, {
    key: 'get',
    value: function get() {
      if (!this.setting) {
        this.load();
      }

      return this.setting;
    }
  }, {
    key: 'getIndex',
    value: function getIndex() {
      if (!this.setting) {
        this.load();
      }

      return this.index;
    }
  }, {
    key: 'getSettings',
    value: function getSettings() {
      if (!this.setting) {
        this.load();
      }

      return this.settings;
    }
  }, {
    key: 'getDefaultSetting',
    value: function getDefaultSetting() {
      return {
        name: 'New Setting',
        address: location.hostname,
        port: 9090,
        log: '/rosout',
        imagePreview: { port: 0, quality: 70, width: 640, height: 480 },
        battery: true,
        batteryTopic: '',
        advanced: false
      };
    }
  }]);

  return SettingsService;
}();

angular.module('roscc').service('Settings', SettingsService);
'use strict';

function topicDirective() {
  return {
    scope: { topic: '=' },
    template: '<ng-include src=\"vm.fileName\"></ng-include>',
    controllerAs: 'vm',
    controller: function controller($scope, $timeout, $http, Settings, Quaternions) {

      var _this = this;
      console.log("Creating new topic for name: ", $scope.topic.name, "; type: ", $scope.topic.type);

      var roslibTopic = new ROSLIB.Topic({
        ros: ros,
        name: $scope.topic.name,
        messageType: $scope.topic.type,
        queue_size: 1
      });
      var path = 'app/topics/';

      this.topic = $scope.topic;
      this.toggleSubscription = toggleSubscription;
      this.publishMessage = publishMessage;
      this.isSubscribing = false;
      this.setting = Settings.get();
      this.Quaternions = Quaternions;
      this.fileName = path + 'default.html';

      // Check if file exists
      $scope.$watch('topic.type', function () {
        if (!$scope.topic.type) {
          return;
        }
        var fileName = path + $scope.topic.type + '.html';
        _this.topic = $scope.topic;
        $http.get(fileName).then(function (result) {
          if (result.data) {
            _this.fileName = fileName;
          }
        });
      });

      function toggleSubscription(data) {
        var _this2 = this;
        if (!data) {
          console.log("ROSLIBTOPIC: ", roslibTopic);
          roslibTopic.subscribe(function (message) {
            $timeout(function () {
              // get the incoming message for the given topic
//              console.log(message);
              _this2.message = message;
            });
          });
        } else {
          roslibTopic.unsubscribe();
        }
        this.isSubscribing = !data;
      }

      function publishMessage(input, isJSON) {
        var data = isJSON ? angular.fromJSON(input) : input;
        var message = new ROSLIB.Message(data);
        roslibTopic.publish(message);
      }
    }
  };
}

angular.module('roscc').directive('ccTopic', topicDirective);


/**
 * Controller for the main dashboard
 *
 * This controller is different than the default topic controller provided by the Ros Control Center
 * Here, we want to mix together data from multiple topics in one display.
 * In order to do this we need to subscribe to each topic and make their data available in a way that they don't overwrite eachother
 *
 * To make the data available, we create a dicitonary called *message*.
 * We then break each topics name and type into keys that are used to create a nested dicitonary structures.
 * For example, the topic that contains the vehicle state information is:
 *    - name:  /VehicleState
 *    - type:  /rsl_rover_msgs/vehicle_state
 *
 * The data for that topic will then live at:
 *    - messages.VehicleState.rsl_rover_msgs.vehicle_state
 *
 * The data itself comes through as a JSON object which is then converted into a dicitonary
 * So to get the wheel_speed of the rover we access:
 *    - messages.VehicleState.rsl_rover_msgs.vehicle_state.wheel_speed
 */
function dashboardDirective() {
  return {
    scope: { topic: '=' },
    template: '<ng-include src=\"vm.fileName\"></ng-include>',
    controllerAs: 'vm',
    controller: function controller($scope, $timeout, $http, Settings, Quaternions) {
      var _this = this;

      // given a topic name and type, we create a nested dicitonary structure
      // each string before or after a '/' becomes a new key to an empty dictionary
      this.MessageToDict = function(name, type) {
        console.log(name, type);
        var messages = {};
        var sub_message = messages;
        var name_splice = name.split("/");
        for (var i = 1; i < name_splice.length; i++) {
          sub_message[name_splice[i]] = {};
          sub_message = sub_message[name_splice[i]];
        }
        var type_splice = type.split("/");
        for (var i = 0; i < type_splice.length; i++) {
          sub_message[type_splice[i]] = {};
          sub_message = sub_message[type_splice[i]];
        }
        return messages;
      }

      // general topics that we want to visualize
      this.topics = [
        {"name": "/EnvData/curly", "type":"rsl_rover_msgs/env_data", "throttle":200},     // sensor box 1
        {"name": "/EnvData/moe", "type":"rsl_rover_msgs/env_data", "throttle":200},       // sensor box 2
        {"name": "/EnvData/larry", "type":"rsl_rover_msgs/env_data", "throttle":200},     // sensor box 3
        {"name": "/VehicleState", "type":"rsl_rover_msgs/vehicle_state", "throttle":100}, // vehicle state information
      ];
     
      // the gas sensor topics are special, so we need to deal with them seperately
      // we want to monitor them as a group and aggregate their values
      // but we only want to use certain sensors for certain gases
      this.gasTopics = {
        CO:       {topics:[this.topics[0], this.topics[1], this.topics[2]], sensors:["MQ7", "MQ9"]},
        CO2:      {topics:[this.topics[0], this.topics[1], this.topics[2]], sensors:["MQ7", "MQ9"]},
        Propane:  {topics:[this.topics[0], this.topics[1], this.topics[2]], sensors:["MQ2", "MQ5", "MQ6", "MQ9"]},
        Methane:  {topics:[this.topics[0], this.topics[1], this.topics[2]], sensors:["MQ4"]}
      }
      this.roslibTopics = {}
      this.messages = {};

      // build a ROSLIB Topic for each topic in the list
      // and construct the holder for all the different message types
      for (var topic in this.topics) {
        this.roslibTopics[_this.topics[topic].name] = new ROSLIB.Topic({
          ros: ros,
          name: _this.topics[topic].name,
          messageType: _this.topics[topic].type,
          throttle: _this.topics[topic].throttle,
          queue_size: 0
        });

        angular.merge(this.messages, this.MessageToDict(this.topics[topic].name, this.topics[topic].type));
      }
      console.log(this.messages);
      var path = 'app/topics/';

      this.topic = $scope.topic;
      this.isSubscribing = false;
      this.setting = Settings.get();
      this.Quaternions = Quaternions;
      this.fileName = path + 'default.html';

      // Check if file exists
      $scope.$watch('topic.type', function () {
        var fileName = path + "dashboard/dashboard2.html";
        _this.topic = $scope.topic;
        $http.get(fileName).then(function (result) {
          if (result.data) {
            _this.fileName = fileName;
          }
        });
      });

      this.roslibTopics['/EnvData/curly'].subscribe(function(message) {
        $timeout(function() {
          _this.messages['EnvData']['curly']['rsl_rover_msgs']['env_data'] = message;
        }, 1000);
      });

      this.roslibTopics['/EnvData/moe'].subscribe(function(message) {
        $timeout(function() {
          _this.messages['EnvData']['moe']['rsl_rover_msgs']['env_data'] = message;
        }, 1000);
      });

      this.roslibTopics['/EnvData/larry'].subscribe(function(message) {
        $timeout(function() {
          _this.messages['EnvData']['larry']['rsl_rover_msgs']['env_data'] = message;
        }, 1000);
      });

      this.roslibTopics['/VehicleState'].subscribe(function(message) {
        $timeout(function() {
          _this.messages['VehicleState']['rsl_rover_msgs']['vehicle_state'] = message;
        }, 1000);
      });

      /*for (topic in this.roslibTopics) {
        var t = this.roslibTopics[topic];
        console.log("Subscribing to ", t.name);
        //subscribe to topic and store messages in appropriate place
        t.subscribe(function(message) {
          $timeout(function () {
             var name_splice = t.name.split("/");
             var accessor;
             accessor = _this.messages[name_splice[1]];
             if(name_splice.length > 2) {
                console.log("CHECKING NAME SPLICE: ", name_splice[2]);
                accessor = accessor[name_splice[2]];
              }
            var type_splice = t.messageType.split("/");
            //console.log(name_splice, type_splice);
            //console.log(message);
            accessor[type_splice[0]][type_splice[1]]=message;
            console.log(accessor);
          }, 1000);
        });
      }*/
    }
  };
}
angular.module('roscc').directive('dashTopic', dashboardDirective);


/**
 * Controller to initialize the a LIDAR view
 *
 * This function will use the ROSLIB and ROS3DJS libraries to render a live point cloud on a page.
 * It requires four different parts:
 *  - ROS connection
 *  - TF Client
 *  - URDF model
 *  - PointCloud
 *
 * The TF client is what makes everything come together.  It does all of the translations to make sure that the URDF model and the PointCloud are rendered in the same scene.
 * We also use a SceneNode to have a little more control over the initialization.
 * The default viewer object makes some assumptions that we did not want to abide by.
 */
function angularLidarViz(){
  return {
    controller: function controller($scope, $timeout, $http, Settings, Quaternions) {
      $scope.init = function(height, divID) {
        /**
        * Setup all visualization elements when the page is loaded.
        */
        // Connect to ROS.
        this.settings = Settings.get();
        var _this = this;
        var ros = new ROSLIB.Ros({
          url : "ws://"+_this.settings.address + ":"+_this.settings.port
        });

        // Create the main viewer.
        var width = $("#lidar_viz").width();
        var viewer = new ROS3D.Viewer({
          divID : divID,
          width : width,
          height : height,
          antialias : false
        });

        // Add a grid.
        viewer.addObject(
          new ROS3D.Grid({
            cellSize: 0.5,
            num_cells: 100
          })
        );

        // Setup a client to listen to TFs.
        // Base_link will redner everything in relation to the base of the rover
        var tf_base = new ROSLIB.TFClient({
          ros : ros,
          angularThres : 0.01,
          transThres : 0.01,
          rate : 5.0,
          fixedFrame : '/base_link'
        });

        // setup a TF client for the world
        // this will render something with relation to the general WORLD that the rover is in
        var tf_cloud = new ROSLIB.TFClient({
          ros : ros,
          angularThres : 0.01,
          transThres : 0.01,
          rate : 5.0,
          fixedFrame : '/map'
        });

        // we want our scene to be focused around the WORLD in which the rover is in
        // for our purposes we want the tfClient and the frameId to reference the same topic
        var urdfScene = new ROS3D.SceneNode({
           tfClient : tf_cloud,
           frameID  : '/map',
        });

        // add the scene to the viewer object
        viewer.scene.add(urdfScene);


        // create a new pointcloud object
        // our pointcloud is rendered via the /ass_cloud topic (short for /assembled_cloud)
        // we use the tf_bae TF client in order to render the point cloud in relation to the rover
        var pointcloud = new ROS3D.PointCloud2({
          ros: ros,
          topic: "/ass_cloud",
          tfClient: tf_base,
          rootObject: urdfScene,
          size: 0.7,
          max_pts: 75000      //save up to 75000 points in the scene at any given time
        });


        // Setup the URDF client.
        // we use the TF Base client here too in order to render the vehicles position relative to itself
        // NOTE:  the URDF model is stored locally at /urdf
        //        if the model ever updates, we need to update it here too
        var urdfClient = new ROS3D.UrdfClient({
          ros : ros,
          tfClient : tf_base,
          path : 'http://localhost:8000/urdf/',
          rootObject : urdfScene,
          loader : ROS3D.COLLADA_LOADER_2
         });
      };
    }
  }
}
angular.module('roscc').directive('lidarViz', angularLidarViz);
\end{verbatim}



\section{User Interface Speed Chart}
\begin{verbatim}
'use strict';
angular.module("roscc").requires.push('highcharts-ng');

var ctrl = angular.module('roscc').controller("speedChartController", function ($scope, $timeout, $parse){
    console.log("Scope: ", $scope);
      $scope.speedChartConfig = {
        options: {
            chart: {
                type: 'gauge',
            },
            // the value axis
            yAxis: {
                min: 0,
                max: 10,
                
                minorTickInterval: 'auto',
                minorTickWidth: 1,
                minorTickLength: 10,
                minorTickPosition: 'inside',
                minorTickColor: '#666',
        
                tickPixelInterval: 30,
                tickWidth: 2,
                tickPosition: 'inside',
                tickLength: 10,
                tickColor: '#666',
                labels: {
                    step: 2,
                    rotation: 'auto'
                },
                title: {
                    text: 'm/s'
                },
                plotBands: [{
                    from: 0,
                    to: 5,
                    color: '#55BF3B' // green
                }, {
                    from: 5,
                    to: 7,
                    color: '#DDDF0D' // yellow
                }, {
                    from: 7,
                    to: 10,
                    color: '#DF5353' // red
                }]        
            },
            pane: {
                startAngle: -150,
                endAngle: 150,
                background: [{
                    backgroundColor: {
                        linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
                        stops: [
                            [0, '#FFF'],
                            [1, '#333']
                        ]
                    },
                    borderWidth: 0,
                    outerRadius: '109%'
                }, {
                    backgroundColor: {
                        linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
                        stops: [
                            [0, '#333'],
                            [1, '#FFF']
                        ]
                    },
                    borderWidth: 1,
                    outerRadius: '107%'
                }, {
                    // default background
                }, {
                    backgroundColor: '#DDD',
                    borderWidth: 0,
                    outerRadius: '105%',
                    innerRadius: '103%'
                }]
            },
        },//end options
        title: {
            text: "Speed (m/s)"
        },
        series: [{
            name: 'speed',
            data: [0],
            tooltip: {
                valueSuffix: ' m/s',
            },
            dataLabels: {
                format: "{y:.1f}"
            }
        }],
        plotOptions: {
            series: {
                marker: {
                    enabled: false
                }
            },
            dataLabels: {
                format: "{y:.2f}"
            }
        },
        func: function(chart) {
            $timeout(function() {
                chart.reflow();
            }, 10);
        },    
        useHighStock: true,

    };

    $scope.init = function(topic_name, chart_height) {
        $scope.topicName = topic_name;
        if (chart_height != undefined) {
            $scope.speedChartConfig.options.chart.height = chart_height;
        }
    }

    if ($scope.chart_height){
        $scope.speedChartConfig.options.chart.height = $scope.chart_height;
    }

    function deref(obj, s) {
      var i = 0;
      if (!s) {
        return undefined;
      }
      s = s.split('.');
      while (i < s.length) {
            obj = obj[s[i]];
            if (obj === undefined)
                return obj;
            i = i + 1;
        }
    return obj;
    }
    function getTopicName() {
        return $scope.topicName;
    }

    // watch the message and update the chart whenever the value updates
    var topicName = $scope.topicName;
    $scope.$watch(function($scope) {
        var val = deref($scope, $scope.topicName);
        return val;
    },function(val){
        if(val){
            $scope.speedChartConfig.series[0].data[0] = Math.abs(val);
        }
    }, false);
    /*var _scope = $scope;
    $scope.$watch(model, function(newValue, oldValue){
        console.log(newValue, oldValue, model);
        if (newValue){
            console.log('Updating value!')
            _scope.speedChartConfig.series[0].data[0] = Math.abs(newValue);
        }
    })*/
});

\end{verbatim}


\section{User Interface Gas Sensor Charts}
\begin{verbatim}
'use strict';
angular.module("roscc").requires.push('highcharts-ng');

var ctrl = angular.module('roscc').controller("gasChart", function ($scope, $timeout){
      $scope.gasChart = {
        options: {
            "chart": {
                "type": "solidgauge",
            },
            exporting: { 
                "enabled": false 
            },
            "pane": {
                "center": [
                    "50%",
                    "85%"
                ],
                "size": "100%",
                "startAngle": "-90",
                "endAngle": "90",
                "background": {
                    "backgroundColor": "#EEE",
                    "innerRadius": "60%",
                    "outerRadius": "100%",
                    "shape": "arc"
                }
            },
            "tooltip": {
                "enabled": false
            },
            "yAxis": {
                "stops": [
                    [
                        0.1,
                        "#55BF3B"
                    ],
                    [
                        0.5,
                        "#DDDF0D"
                    ],
                    [
                        0.75,
                        "#DF5353"
                    ]
                ],
                "min": 0,
                "max": 100,
                "lineWidth": 0,
                "minorTickInterval": null,
                "tickPixelInterval": 400,
                "tickWidth": 0,
                "title": {
                    margin:0,
                },
                "labels": {
                    "y": 10
                },
                "showFirstLabel":false,
                "showLastLabel":false,
            },
            "title":{
                "text":"Gas",
                "margin": 0
            }
        }, //end options
        "plotOptions": {
                "solidgauge": {
                    "dataLabels": {
                        "y": 10,
                        "borderWidth": 0,
                        "useHTML": true
                    }
                }
        },
       'series': [{
            'name': 'gas',
            'data': [0],
            "dataLabels": {
                "format": '<div style="text-align:center"><span style="font-size:8px;color:' +
                    ((Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black') + '">{y:.1f}</span><br/>'
            },
        }],
        func: function(chart) {
            $timeout(function() {
                chart.reflow();
            }, 100);
        },    
        useHighStock: true
    };
    $scope.init = function(gas_name, chart_height, chart_title) {
        /**
         * topic_names is a list of all the different gas sensor topics
         */
        $scope.gas_name = gas_name;
        $scope.chart_height = chart_height;
        $scope.chart_title = chart_title;
        if (chart_height != undefined) {
            $scope.gasChart.options.chart.height = chart_height;
        }
        if ($scope.chart_title) {
            $scope.gasChart.options.title.text = chart_title;
        }
        $scope.topicNames = $scope.vm.gasTopics[gas_name];
    };
    function deref(obj, s) {
      var i = 0;
      if (!s) {
        return undefined;
      }
      s = s.split('.');
      while (i < s.length) {
            obj = obj[s[i]];
            if (obj === undefined)
                return obj;
            i = i + 1;
        }
    return obj;
    };
    function getMessageName(topic) {
        var name_splice = topic.name.split("/");
        var type_splice = topic.type.split("/");
        return ("vm.messages."+name_splice[1] +"."+name_splice[2]+"."+type_splice[0]+"."+type_splice[1]+".");
    };

    $scope.$watch(function($scope) {
        var val = 0;
        // for each of the sensor packs, there are certain sensors that are better than others for certain gases
        // these are listed under *sensors*
        // So we want to add and average these different sensor values for each sensor pack
        $.each($scope.topicNames.topics, function(e) {
            var sensor_pack = $scope.topicNames.topics[e];
            var sensor_average = 0;
            var count = 0;
            // iterate over each sensor
            //console.log($scope.topicNames.sensors);
            $.each($scope.topicNames.sensors, function(s){
                var sensor = $scope.topicNames.sensors[s];
                var sensor_path = getMessageName(sensor_pack)+sensor+"."+$scope.gas_name;
                var sensor_val = deref($scope, sensor_path);
                if (sensor_val) {
                    sensor_average += sensor_val;
                    count++;
                }

            });
            sensor_average = sensor_average/count;
            val += sensor_average;
        });
        return (val/$scope.topicNames.topics.length);
    },function(val){
        if(val){
            $scope.gasChart.series[0].data[0] = Math.abs(val);
        }
    }, false);
});
console.log("Loaded controller: ", ctrl);
\end{verbatim}


\section{User Interface HTML Dashboard}
\begin{verbatim}
<div class="panel panel-default" ng-class="{'panel-success': vm.toggle}" id="dashboard_panel">
    <div class="panel-heading clearfix">
    </div>
    <div class="panel-body">
        <p>Timestamp: {{ vm.messages.VehicleState.rsl_rover_msgs.vehicle_state.header.stamp.secs * 1000 | date:'yyyy-MM-dd HH:mm:ss Z'}}</p>
        <div class="container-fluid">
            <div class="col-lg-2">
                <div id="cameras">
                    <img class="img-responsive img-thumbnail" ng-src="http://{{ vm.setting.raspberry_pi.address }}:{{ vm.setting.raspberry_pi.imagePreview.port }}/stream?topic={{ vm.setting.raspberry_pi.camera.front}}&quality={{ vm.setting.imagePreview.quality }}&width=180&height=135">
                    <img class="img-responsive img-thumbnail" ng-src="http://{{ vm.setting.raspberry_pi.address }}:{{ vm.setting.raspberry_pi.imagePreview.port }}/stream?topic={{ vm.setting.raspberry_pi.camera.right}}&quality={{ vm.setting.imagePreview.quality }}&width=180&height=135">
                    <img class="img-responsive img-thumbnail" ng-src="http://{{ vm.setting.raspberry_pi.address }}:{{ vm.setting.raspberry_pi.imagePreview.port }}/stream?topic={{ vm.setting.raspberry_pi.camera.left}}&quality={{ vm.setting.imagePreview.quality }}&width=180&height=135">
                    <img class="img-responsive img-thumbnail" ng-src="http://{{ vm.setting.raspberry_pi.address }}:{{ vm.setting.raspberry_pi.imagePreview.port }}/stream?topic={{ vm.setting.raspberry_pi.camera.back}}&quality={{ vm.setting.imagePreview.quality }}&width=180&height=135">
                </div>
            </div>
            <div class="col-lg-7">
                <div lidar-viz id ="lidar_viz" style="height:500px; width:100%" ng-init="init(500, 'lidar_viz')">
                </div>
            </div>
            <div class="col-lg-3">
                <!-- SPEDOMETER -->
                <div ng-controller="speedChartController" ng-init="init('vm.messages.VehicleState.rsl_rover_msgs.vehicle_state.wheel_speed', 200);">
                    <highchart id="speed_chart" config="speedChartConfig" class="chart"></highchart>
                </div>
                <div class="row">
                  <div class="col-lg-6">
                        <div ng-controller="gasChart">
                            <highchart id="c02Chart" config="gasChart" class="chart" ng-init="init('CO2', 120, 'CO2')"></highchart>
                        </div>
                    </div>
                    <div class="col-lg-6">
                        <div ng-controller="gasChart">
                            <highchart id="c0Chart" config="gasChart" class="chart" ng-init="init('CO', 120, 'CO')"></highchart>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="col-lg-6">
                        <div ng-controller="gasChart">
                            <highchart id="GasChart" config="gasChart" class="chart" ng-init="init('Methane', 120, 'CH4')"></highchart>
                        </div>
                    </div>
                    <div class="col-lg-6">
                        <div ng-controller="gasChart">
                            <highchart id="PropaneChart" config="gasChart" class="chart" ng-init="init('Propane', 120, 'C3H8')"></highchart>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
\end{verbatim}


\section{User Interface HTML Vehicle State}
\begin{verbatim}
<div class="panel panel-default" ng-class="{'panel-success': vm.toggle}">
    <div class="panel-heading clearfix">
        <button id="vehicle_state_sub" class="btn btn-default btn-sm pull-right" ng-click="vm.toggleSubscription(!vm.toggle)" ng-model="vm.toggle" uib-btn-checkbox>{{ vm.toggle ? 'Unsubscribe' : 'Subscribe' }}</button>
        <h3 class="panel-title">
            {{ vm.topic.abbr }}
            <small style="font-size: 12px;">({{ vm.topic.type }})</small>
        </h3>
    </div>
    <div class="alert alert-danger" ng-show="vm.message.estop != null && vm.message.estop != false">
        ESTOP Occured! Code: <strong>{{vm.message.estop_code}}</strong>
    </div>

    <div class="panel-body">
        <div class ="row">
            <div class="col-sm-12">
                <div class="form-group">
                    <label>Timestamp</label>
                    {{ vm.message.header.stamp.secs * 1000 | date:'yyyy-MM-dd HH:mm:ss Z'}}
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-sm-6">
                <form class="form-horizontal form-margin">
                    <div class="form-group">
                        <div class="row">
                            <div ng-controller="wheelAngleChart">
                                <highchart id="actual_steering_chart" config="wheelAngleConfig" topicName="vm.message.actual_steering" class="chart"></highchart>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <label>Actual Steering</label>
                                <div class="input-group">
                                    <input type="number" class="form-control" ng-model="vm.message.actual_steering" ng-readonly="vm.isSubscribing">
                                    <span class="input-group-addon">degrees</span>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <label>Desired Steering</label>
                                <div class="input-group">
                                    <input type="number" class="form-control" ng-model="vm.message.desired_steering" ng-readonly="vm.isSubscribing">
                                    <span class="input-group-addon">degrees</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Wheel Pos</label>
                        <div class="input-group">
                            <input type="number" class="form-control" ng-model="vm.message.wheel_pos" ng-readonly="vm.isSubscribing">
                            <span class="input-group-addon">m/s<sup>2</sup></span>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Desired Throttle</label>
                        <div class="input-group">
                            <input type="number" class="form-control" ng-model="vm.message.desired_throttle" ng-readonly="vm.isSubscribing">
                            <span class="input-group-addon">m/s</span>
                        </div>
                    </div>
                </form>
            </div>
            <div class="col-sm-6">
                <form class="form-horizontal form-margin">
                    <div class="form-group">
                        <div ng-controller="speedChartController" ng-init="topicName='vm.message.wheel_speed'">
                            <highchart id="speed_chart" config="speedChartConfig" class="chart"></highchart>
                        </div>
                        <label>Wheel Speed</label>
                        <div class="input-group">
                            <input id='wheel_speed_val' type="number" class="form-control" ng-model="vm.message.wheel_speed" ng-readonly="vm.isSubscribing">
                            <span class="input-group-addon">m/s</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="row">
                            <div class="col-md-6">
                                <label>Desired Gear</label>
                                <div class="input-group">
                                    <input type="string" class="form-control" ng-model="vm.message.desired_gear" ng-readonly="vm.isSubscribing">
                                </div>
                            </div>
                            <div class="col-md-6">
                                <label>Actual Gear</label>
                                <div class="input-group">
                                    <input type="string" class="form-control" ng-model="vm.message.actual_gear" ng-readonly="vm.isSubscribing">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Voltage Warn</label>
                        <div class="input-group">
                            <input type="bool" class="form-control" ng-class="{'bg-danger':vm.message.voltage_warn}" ng-model="vm.message.voltage_warn" ng-readonly="vm.isSubscribing">
                        </div>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>
\end{verbatim}






